// Generated by CoffeeScript 1.4.0
(function() {
  var exports, headingRuleTable, image, inHeading, inLinkText, inListItem, inParagraph, inRoot, inTableCell, itemPrefixes, linkOptions, linkPattern, linkPatterns, linkTextMarkups, match, parse, parseHeading, parseLine, parseLinkText, parseList, parseMacroParameters, parseNowiki, parseParagraph, parseTable, parseTableRow, parseText, rawUrl, rootPrefixes, skipWhitespace, style_BOLD, style_BOLD_ITALICS, style_ITALICS, style_ITALICS_BOLD, style_NONE, textMarkups, urlPrefix, _ref;

  match = function(rx, source, i) {
    rx.lastIndex = i;
    return rx.exec(source);
  };

  skipWhitespace = function(source, i) {
    var rx;
    rx = /[\t ]*/g;
    rx.lastIndex = i;
    rx.test(source);
    return rx.lastIndex;
  };

  linkOptions = function(internal, external, interwiki) {
    if (internal != null) {
      return {
        type: 'internal',
        link: internal
      };
    } else if (external != null) {
      return {
        type: 'external',
        link: external
      };
    } else {
      return {
        type: 'interwiki',
        link: interwiki
      };
    }
  };

  style_NONE = 0;

  style_BOLD = 1;

  style_ITALICS = 2;

  style_BOLD_ITALICS = 3;

  style_ITALICS_BOLD = 4;

  linkPattern = '[^\\]|~\\n]*(?:(?:\\](?!\\])|~.)[^\\]|~\\n]*)*';

  urlPrefix = '\\b(?:(?:https?|ftp)://|mailto:)';

  linkPatterns = ['(' + urlPrefix + linkPattern + ')', '([\\w.]+:' + linkPattern + ')', '(' + linkPattern + ')'].join('|');

  rawUrl = urlPrefix + '\\S*[^\\s!"\',.:;?]';

  image = '\\{\\{(?:' + linkPatterns + ')(?:\\|([^\\}~\\n]*(?:(?:\\}(?!\\})|~.)[^\\}~\\n]*)*))?\\}\\}';

  linkTextMarkups = ['\\*\\*', '\\/\\/', '\\\\\\\\', '\\{\\{\\{.*?\\}\\}\\}+', image].join('|');

  inLinkText = new RegExp('(\\]\\]|\\n|$)|' + linkTextMarkups + '|~.', 'g');

  textMarkups = [linkTextMarkups, '\\[\\[(?:' + linkPatterns + ')(?:\\||\\]\\])', rawUrl, '<<[A-Za-z_]\\w*', '~(?:' + rawUrl + '|.)'].join('|');

  inHeading = new RegExp('((?:[\\t ]=+[\\t ]*)?(?:\\n|$))|' + textMarkups, 'g');

  inTableCell = new RegExp('(\\||\\n|$)|' + textMarkups, 'g');

  headingRuleTable = '={1,6}[\\t ]|----[\\t ]*(?:\\n|$)|\\|';

  itemPrefixes = headingRuleTable + '|[*#]*(?:\\*(?!\\*)|#(?!#))';

  inListItem = new RegExp('(\\n(?:\\n|[\\t ]*(?:' + itemPrefixes + ')|\\{\\{\\{\\n)|$)|' + textMarkups, 'g');

  rootPrefixes = headingRuleTable + '|\\*(?!\\*)|#(?!#)';

  inParagraph = new RegExp('(\\n(?:\\n|[\\t ]*(?:' + rootPrefixes + ')|\\{\\{\\{\\n)|$)|' + textMarkups, 'g');

  inRoot = new RegExp('([\\t ]*)(' + rootPrefixes + '|(.?))', 'g');

  parseLine = function(rx, target, source, i, other) {
    var options, result, style, _ref;
    style = style_NONE;
    while (true) {
      result = match(rx, source, i);
      if (result.index > i) {
        target.text(source.substring(i, result.index));
      }
      if (result[1] != null) {
        switch (style) {
          case style_BOLD:
          case style_ITALICS:
            target.end();
            break;
          case style_BOLD_ITALICS:
          case style_ITALICS_BOLD:
            target.end();
            target.end();
        }
        return result.index;
      }
      i = rx.lastIndex;
      switch (result[0].substr(0, 2)) {
        case '**':
          switch (style) {
            case style_BOLD:
              target.end();
              style = style_NONE;
              break;
            case style_ITALICS:
              target.start('bold');
              style = style_ITALICS_BOLD;
              break;
            case style_BOLD_ITALICS:
              target.end();
              target.end();
              style = style_NONE;
              break;
            case style_ITALICS_BOLD:
              target.end();
              style = style_ITALICS;
              break;
            default:
              target.start('bold');
              style = style_BOLD;
          }
          break;
        case '//':
          switch (style) {
            case style_BOLD:
              target.start('italics');
              style = style_BOLD_ITALICS;
              break;
            case style_ITALICS:
              target.end();
              style = style_NONE;
              break;
            case style_BOLD_ITALICS:
              target.end();
              style = style_BOLD;
              break;
            case style_ITALICS_BOLD:
              target.end();
              target.end();
              style = style_NONE;
              break;
            default:
              target.start('italics');
              style = style_ITALICS;
          }
          break;
        case '\\\\':
          target.start('lineBreak');
          target.end();
          break;
        case '{{':
          if (result[0].charAt(2) === '{') {
            target.start('inlineNowiki');
            target.text(source.substring(result.index + 3, i - 3));
          } else {
            options = linkOptions(result[4], result[2], result[3]);
            options.title = (_ref = result[5]) != null ? _ref.replace(/~(.)/g, '$1') : void 0;
            target.start('image', options);
          }
          target.end();
          break;
        default:
          i = other(target, result, i);
      }
    }
  };

  parseLinkText = function(target, source, i) {
    i = parseLine(inLinkText, target, source, i, function(target, result, i) {
      target.start('escaped');
      target.text(result[0].charAt(1));
      target.end();
      return i;
    });
    switch (source.charAt(i)) {
      case '\n':
        ++i;
        break;
      case ']':
        ++i;
        if (source.charAt(i) === ']') {
          ++i;
        }
    }
    return i;
  };

  parseMacroParameters = function(source, i) {
    var parameters, result, rx;
    rx = />>|[\t ]+([A-Za-z_]\w*)='([^'\\]*(?:\\.|[^'\\])*)'|(.?)/g;
    parameters = {};
    while (true) {
      result = match(rx, source, i);
      if (result[3] != null) {
        return null;
      }
      i = rx.lastIndex;
      if (result[0].charAt(0) === '>') {
        break;
      }
      parameters[result[1]] = result[2].replace(/\\(.)/g, '$1');
    }
    return [i, parameters];
  };

  parseText = function(rx, target, source, i) {
    return i = parseLine(rx, target, source, i, function(target, result, i) {
      var ip, _ref, _ref1;
      switch (result[0].charAt(0)) {
        case '[':
          target.start('link', linkOptions(result[8], result[6], result[7]));
          if (result[0].charAt(result[0].length - 1) === '|') {
            i = parseLinkText(target, source, i);
          } else {
            target.text((_ref = (_ref1 = result[6]) != null ? _ref1 : result[7]) != null ? _ref : result[8]);
          }
          break;
        case '<':
          ip = parseMacroParameters(source, i);
          if (ip) {
            i = ip[0];
            target.start('macro', {
              name: result[0].substr(2),
              parameters: ip[1]
            });
          } else {
            target.text(result[0]);
            return i;
          }
          break;
        case '~':
          target.start('escaped');
          target.text(result[0].substr(1));
          break;
        default:
          target.start('url', {
            link: result[0]
          });
      }
      target.end();
      return i;
    });
  };

  parseHeading = function(n, target, source, i) {
    var rx;
    target.start('heading' + (n - 1));
    rx = /\n|$/g;
    rx.lastIndex = parseText(inHeading, target, source, i + n);
    rx.test(source);
    target.end();
    return rx.lastIndex;
  };

  parseTableRow = function(target, source, i) {
    target.start('tableRow');
    while (true) {
      if (source.charAt(++i) === '=') {
        ++i;
        target.start('tableHeading');
      } else {
        i = skipWhitespace(source, i);
        if (source.charAt(i) === '' || source.charAt(i) === '\n') {
          break;
        }
        target.start('tableCell');
      }
      i = parseText(inTableCell, target, source, i);
      target.end();
      if (source.charAt(i) !== '|') {
        break;
      }
    }
    target.end();
    if (source.charAt(i) === '\n') {
      ++i;
    }
    return i;
  };

  parseTable = function(target, source, i) {
    var j;
    target.start('table');
    while (true) {
      i = parseTableRow(target, source, i);
      j = skipWhitespace(source, i);
      if (source.charAt(j) !== '|') {
        break;
      }
      i = j;
    }
    target.end();
    return i;
  };

  parseList = function(prefix, target, source, i) {
    var b, j, result, rx, type;
    type = prefix.charAt(prefix.length - 1);
    target.start(type === '*' ? 'unorderedList' : 'orderedList');
    rx = /(?:\*(?!\*)|#(?!#))|(.*)/g;
    b = true;
    while (b) {
      target.start('listItem');
      i = parseText(inListItem, target, source, i + prefix.length);
      if (source.charAt(i) === '\n') {
        ++i;
      }
      while (true) {
        j = skipWhitespace(source, i);
        if (source.substr(j, prefix.length) !== prefix) {
          b = false;
          break;
        }
        result = match(rx, source, j + prefix.length);
        if (result[1] != null) {
          if (result[1] === type) {
            b = false;
          } else {
            i = j;
          }
          break;
        }
        i = parseList(prefix + result[0], target, source, j);
      }
      target.end();
    }
    target.end();
    return i;
  };

  parseNowiki = function(target, source, i) {
    var result, rx;
    target.start('nowiki');
    rx = /\n\}\}\}(?:\n|$)|$/g;
    result = match(rx, source, i);
    target.text(source.substring(i, result.index).replace(/^ ([\t ]*\}\}\})/gm, '$1'));
    target.end();
    return rx.lastIndex;
  };

  parseParagraph = function(target, source, i) {
    target.start('paragraph');
    i = parseText(inParagraph, target, source, i);
    target.end();
    if (source.charAt(i) === '\n') {
      ++i;
      if (source.charAt(i) === '\n') {
        ++i;
      }
    }
    return i;
  };

  parse = function(target, source) {
    var i, n, result, _results;
    n = source.length;
    i = 0;
    _results = [];
    while (i < n) {
      if (source.substr(i, 4) === '{{{\n') {
        _results.push(i = parseNowiki(target, source, i + 4));
      } else if (source.charAt(i) === '\n') {
        _results.push(++i);
      } else {
        result = match(inRoot, source, i);
        i += result[1].length;
        if (result[3] != null) {
          _results.push(i = parseParagraph(target, source, i));
        } else {
          switch (result[2].charAt(0)) {
            case '=':
              _results.push(i = parseHeading(result[2].length, target, source, i));
              break;
            case '-':
              target.start('horizontalRule');
              target.end();
              _results.push(i += result[2].length);
              break;
            case '|':
              _results.push(i = parseTable(target, source, i));
              break;
            default:
              _results.push(i = parseList(result[2], target, source, i));
          }
        }
      }
    }
    return _results;
  };

  exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : {};

  if (typeof window !== "undefined" && window !== null) {
    window.creole = exports;
  }

  exports.parse = parse;

}).call(this);
